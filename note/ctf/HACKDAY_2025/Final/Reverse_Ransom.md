The goal of this challenge was to decrypt `flag.txt`, which was encrypted by the `challenge` binary.

A date is also mentionned : 2025-03-26 22:11:00 this will be usefull

To do this, I need to analyze the ransomware written in C++:

## Main:

```c++
00002320  int32_t main(int32_t argc, char** argv, char** envp)

00002326      void* fsbase
00002326      int64_t rax = *(fsbase + 0x28)
00002345      int64_t s
00002345      __builtin_memset(&s, c: 0, n: 0x18)
00002358      int64_t var_50
00002358      int64_t var_48
00002358      sub_2676(&s, &var_50, &var_48)
0000236b      int64_t rax_1 = sub_27be(s, var_50, var_48)
00002383      void __p
00002383      void* var_40 = &__p
00002388      std::string::_S_copy_chars(&__p, __k1: "flag.txt", __k2: &data_304b[8])
00002398      int64_t var_38 = 8
000023a1      *(var_40 + 8) = 0
000023a5      sub_2b2d(&var_40, rax_1)
000023ad      std::string::_M_dispose(this: &var_40)
000023b7      *(fsbase + 0x28)
000023b7      
000023c0      if (rax == *(fsbase + 0x28))
000023f4          return 0
000023f4      
000023e7      __stack_chk_fail()
000023e7      noreturn
```

Since this is a ransomware, I need to find all the functions related to encryption in order to reverse the process:

## sub\_2676 (N, Q, P):

```C++
00002676  uint64_t sub_2676(int64_t* arg1, int64_t* arg2, int64_t* arg3)

00002682      int32_t r13 = 0
00002695      *arg1 = BN_new()
0000269e      *arg2 = BN_new()
000026a6      *arg3 = BN_new()
000026be      srand(x: (divs.dp.q(sx.o(std::chrono::_V2::system_clock::now()), 0xdf8475800)).d)
000026c3      int64_t rax_6 = BN_CTX_new()
000026c3      
000026d0      if (rax_6 != 0)
000026de          BN_set_word(*arg2, 0x10001)
000026e8          int64_t rax_7 = sub_25d1(0x80)
000026f5          int64_t rax_8 = sub_25d1(0x80)
000026fd          r13.b = rax_7 == 0
00002704          int64_t rbx_1 = rax_8
00002707          rax_8.b = rax_8 == 0
0000270a          r13.b |= rax_8.b
0000270d          int64_t r12_1
0000270d          
0000270d          if (r13.b != 0)
00002775              r12_1 = 0
00002778              r13 = 0
0000270d          else
0000271e              BN_mul(*arg1, rax_7, rbx_1, rax_6)
00002723              int64_t rax_9 = BN_new()
00002728              r12_1 = rax_9
00002728              
0000272e              if (rax_9 != 0)
00002738                  r13.b = 1
0000273b                  BN_sub_word(rax_7, 1)
00002748                  BN_sub_word(rbx_1, 1)
0000275b                  BN_mul(r12_1, rax_7, rbx_1, rax_6)
0000276e                  BN_mod_inverse(*arg3, *arg2, r12_1, rax_6)
0000276e          
00002780          BN_CTX_free(rax_6)
00002780          
00002788          if (r12_1 != 0)
0000278d              BN_free(r12_1)
0000278d          
00002795          if (rax_7 != 0)
0000279a              BN_free(rax_7)
0000279a          
000027a2          if (rbx_1 != 0)
000027a7              BN_free(rbx_1)
000027a7      
000027bd      return zx.q(r13)
```

This function generates a seed for random numbers based on the timestamp divided by 0xdf8475800:
`srand(x: (divs.dp.q(sx.o(std::chrono::_V2::system_clock::now()), 0xdf8475800)).d)`

I also have the generation of the exponent e:

`BN_set_word(*arg2, 0x10001)` which is `65537` (very common)

This function also generates the variables:

p: generated by `int64_t rax_7 = sub_25d1(0x80)`

q: generated by `int64_t rax_8 = sub_25d1(0x80)` (stored in rbx: `int64_t rbx_1 = rax_8`)

n: generated by `BN_mul(*arg1, rax_7, rbx_1, rax_6)` (n = p \* q)

To be as faithful as possible to the program, I must dump the logic of prime number generation (p and q), which is located here: `sub_25d1(0x80)`

## sub\_25d1 (Prime number generation):

```c++
000025d1  int64_t sub_25d1(int32_t arg1)
000025de      int64_t rcx
000025de      int64_t var_38 = rcx
000025df      int64_t result = BN_new()
000025df      
000025e7      if (result != 0)
000025f0          int64_t rax = BN_CTX_new()
000025f0          
000025fb          if (rax != 0)
00002606              char* rax_1 = operator new[](sz: sx.q(arg1))
0000265d              int32_t i
0000265d              
0000265d              do
0000260e                  int64_t r13_1 = 0
0000260e                  
00002614                  while (arg1 s> r13_1.d)
0000261f                      rax_1[r13_1] = (mods.dp.d(sx.q(rand()), 0x100)).b
00002624                      r13_1 += 1
00002624                  
00002632                  BN_bin2bn(rax_1, zx.q(arg1), result)
0000263c                  BN_set_bit(result, 0)
00002649                  BN_set_bit(result, 0x3ff)
00002656                  i = BN_check_prime(result, rax, 0)
0000265d              while (i == 0)
00002662              operator delete[](ptr: rax_1)
00002675              return result
00002675      
000025e9      return 0
```

I realize that time (which serves as the seed) will play a major role in the generation of prime numbers (and thus the decryption of our file)

`rax_1[r13_1] = (mods.dp.d(sx.q(rand()), 0x100)).b`

I continue the analysis of another function in main:

## sub\_27be (RSA key generation)

```c++
000027be  int64_t sub_27be(int64_t arg1, int64_t arg2, int64_t arg3)

000027d0      void* fsbase
000027d0      int64_t rbx = *(fsbase + 0x28)
000027e1      int64_t result = 0
000027e5      int64_t rax = OSSL_PARAM_BLD_new()
000027e5      
000027ed      if (rax != 0)
0000280a          int64_t rbx_2
0000280a          int64_t r12_1
0000280a          
0000280a          if (OSSL_PARAM_BLD_push_BN(rax, "n", arg1) != 0)
00002827              if (OSSL_PARAM_BLD_push_BN(rax, "e", arg2) == 0)
0000280c                  r12_1 = 0
0000280f                  rbx_2 = 0
00002827              else if (OSSL_PARAM_BLD_push_BN(rax, "d", arg3) == 0)
0000280c                  r12_1 = 0
0000280f                  rbx_2 = 0
0000283d              else
00002842                  int64_t rax_4 = OSSL_PARAM_BLD_to_param(rax)
00002847                  r12_1 = rax_4
00002847                  
0000284d                  if (rax_4 == 0)
0000280c                      r12_1 = 0
0000280f                      rbx_2 = 0
0000284d                  else
0000285a                      int64_t rax_5 = EVP_PKEY_CTX_new_from_name(0, "RSA", 0)
0000285f                      rbx_2 = rax_5
0000285f                      
00002865                      if (rax_5 != 0 && EVP_PKEY_fromdata_init(rax_5) s> 0)
00002881                          EVP_PKEY_fromdata(rbx_2, &result, 0x87, r12_1)
0000280a          else
0000280c              r12_1 = 0
0000280f              rbx_2 = 0
0000280f          
00002889          OSSL_PARAM_BLD_free(rax)
00002889          
00002891          if (r12_1 != 0)
000028a2              CRYPTO_free(r12_1, "challenge.cpp", 0xce)
000028a2          
000028aa          if (rbx_2 != 0)
000028af              EVP_PKEY_CTX_free(rbx_2)
000028af      
000028bd      *(fsbase + 0x28)
000028bd      
000028c6      if (rbx == *(fsbase + 0x28))
000028d7          return result
000028d7      
000028c8      __stack_chk_fail()
000028c8      noreturn
```

Standard OpenSSL implementation for an RSA key with our previously generated parameters

## sub\_2b2d (Encryption):

```c++
00002b2d  int64_t sub_2b2d(std::string_1* arg1, int64_t arg2)

00002b3e      void* fsbase
00002b3e      int64_t rbx = *(fsbase + 0x28)
00002b5a      int64_t var_70
00002b5a      sub_298f(&var_70)
00002b64      int64_t rsi_1 = var_70
00002b6c      int64_t var_68
00002b6c      
00002b6c      if (rsi_1 == var_68)
00002c54          label_2c54:
00002c54          sub_2cb0(&var_70)
00002c54          
00002c67          if (rbx == *(fsbase + 0x28))
00002cae              return rbx - *(fsbase + 0x28)
00002b6c      else
00002b7f          char* var_80 = nullptr
00002b84          std::size_t sz_1 = 0
00002b84          
00002b95          if (sub_24f9(arg2, rsi_1, var_68 - rsi_1, &var_80, &sz_1) == 0)
00002b95              goto label_2c54
00002b95          
00002b9b          std::size_t sz = sz_1
00002ba2          char* rbx_2 = var_80
00002bac          char* s
00002bac          __builtin_memset(&s, c: 0, n: 0x18)
00002bac          
00002bbe          if (sz s>= 0)
00002be0              char* s_1
00002be0              
00002be0              if (sz == 0)
00002bef                  s_1 = nullptr
00002be0              else
00002bea                  s_1 = operator new(sz)
00002bea              
00002bf1              void* r15_1 = &s_1[sz]
00002bf5              s = s_1
00002bfa              void* var_48_1 = r15_1
00002bfa              
00002c03              if (sz s> 1)
00002c0b                  memmove(s_1, rbx_2, sz)
00002c03              else if (sz == 1)
00002c14                  char* rax_2
00002c14                  rax_2.b = *rbx_2
00002c16                  *s_1 = rax_2.b
00002c16              
00002c1e              void* var_50_1 = r15_1
00002c2a              int64_t rdx_3 = 0x34
00002c2a              
00002c36              if (sub_28d8(arg1, &s) == 0)
00002c38                  rdx_3 = 0x30
00002c38              
00002c44              CRYPTO_free(rbx_2, "challenge.cpp", rdx_3)
00002c4c              sub_2cb0(&s)
00002c03              goto label_2c54
00002c03          
00002bc5          *(fsbase + 0x28)
00002bc5          
00002bce          if (rbx == *(fsbase + 0x28))
00002bdb              std::__throw_length_error(what: "cannot create std::vector largerâ€¦")
00002bdb              noreturn
00002bdb      
00002c9b      __stack_chk_fail()
00002c9b      noreturn
```

This one takes `arg2` (the file) as input and proceeds to encrypt it. I keep digging a bit here...

## sub\_24f9 (Padding):

```c++
000024f9  int64_t sub_24f9(int64_t arg1, int64_t arg2, int64_t arg3, int64_t* arg4, 
000024f9      int64_t* arg5)

00002515      int64_t rax = EVP_PKEY_CTX_new(arg1, 0)
0000251d      int64_t result = 0
0000251d      
00002522      if (rax != 0)
00002532          int32_t rax_5
00002532          
00002532          if (EVP_PKEY_encrypt_init(rax) s<= 0)
000025b0              rax_5 = 0
00002532          else if (EVP_PKEY_CTX_set_rsa_padding(rax, 4) s<= 0)
000025b0              rax_5 = 0
00002543          else if (EVP_PKEY_encrypt(rax, 0, arg5, arg2, arg3) s<= 0)
000025b0              rax_5 = 0
0000255a          else
0000256f              int64_t rax_4 = CRYPTO_malloc(*arg5, "challenge.cpp", 0x47)
00002574              *arg4 = rax_4
00002574              
0000257e              if (rax_4 == 0)
000025b0                  rax_5 = 0
0000257e              else
00002593                  rax_5.b = 1
00002593                  
00002597                  if (EVP_PKEY_encrypt(rax, rax_4, arg5, arg2, arg3) s<= 0)
000025a5                      CRYPTO_free(*arg4, "challenge.cpp", 0x4c)
000025ac                      *arg4 = 0
000025b0                      rax_5 = 0
000025b0          
000025b9          EVP_PKEY_CTX_free(rax)
000025be          result.b = rax_5.b
000025be      
000025d0      return result
```

Very interesting information can be seen here:

`EVP_PKEY_CTX_new(pkey, NULL);` â€” Creation of an RSA encryption context

`EVP_PKEY_CTX_set_rsa_padding(rax, 4) s<= 0` â€” Setting RSA padding (very important for decryption!), padding `4` most likely corresponds to `RSA_PKCS1_OAEP_PADDING`

`EVP_PKEY_encrypt(rax, rax_4, arg5, arg2, arg3)` â€” encryption call

## DECRYPTION

I dump all the logic, now it's just a matter of decrypting with the correct padding and the right seed (corresponding to the timestamp used!)

`solver.cpp:`

```c++
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <ctime>
#include <cstdint>
#include <cstring>
#include <openssl/bn.h>
#include <openssl/evp.h>
#include <openssl/rsa.h>

#define FLAG_SIZE 256
#define PRIME_SIZE 128

// Faithful to ransomware's generation
void generate_prime(BIGNUM **out) {
    BN_CTX *ctx = BN_CTX_new();
    unsigned char *buf = new unsigned char[PRIME_SIZE];
    BIGNUM *bn = nullptr;

    do {
        for (int i = 0; i < PRIME_SIZE; ++i)
            buf[i] = std::rand() % 256;

        if (bn) BN_free(bn);
        bn = BN_bin2bn(buf, PRIME_SIZE, nullptr);
        BN_set_bit(bn, 0);
        BN_set_bit(bn, 1023);
    } while (!BN_check_prime(bn, ctx, nullptr));

    delete[] buf;
    BN_CTX_free(ctx);
    *out = bn;
}

EVP_PKEY* build_private_key(BIGNUM *n, BIGNUM *e, BIGNUM *d, BIGNUM *p, BIGNUM *q) {
    RSA *rsa = RSA_new();
    RSA_set0_key(rsa, BN_dup(n), BN_dup(e), BN_dup(d));
    RSA_set0_factors(rsa, BN_dup(p), BN_dup(q));
    EVP_PKEY *pkey = EVP_PKEY_new();
    EVP_PKEY_assign_RSA(pkey, rsa);
    return pkey;
}

bool decrypt_RSA_OAEP(EVP_PKEY *pkey, const unsigned char *ciphertext, size_t ciphertext_len, unsigned char *plaintext, size_t &plaintext_len) {
    EVP_PKEY_CTX *ctx = EVP_PKEY_CTX_new(pkey, NULL);
    if (!ctx || EVP_PKEY_decrypt_init(ctx) <= 0) return false;
    if (EVP_PKEY_CTX_set_rsa_padding(ctx, RSA_PKCS1_OAEP_PADDING) <= 0) return false;
    if (EVP_PKEY_decrypt(ctx, plaintext, &plaintext_len, ciphertext, ciphertext_len) <= 0) return false;
    EVP_PKEY_CTX_free(ctx);
    return true;
}

int main() {
    std::ifstream fin("flag.txt", std::ios::binary);
    if (!fin) {
        std::cerr << "[-] Cannot open flag.txt\n";
        return 1;
    }

    unsigned char ciphertext[FLAG_SIZE];
    fin.read(reinterpret_cast<char *>(ciphertext), FLAG_SIZE);
    if (fin.gcount() != FLAG_SIZE) {
        std::cerr << "[-] Expected " << FLAG_SIZE << " bytes in flag.txt\n";
        return 1;
    }

    time_t ts = 1743023460; // 2025-03-26 22:11:00
    uint32_t seed = static_cast<uint64_t>(ts) * 1000000000ULL / 60000000000ULL;
    std::cout << "[*] Using seed = " << seed << " (from timestamp " << ts << ")\n";
    std::srand(seed);

    BN_CTX *ctx = BN_CTX_new();
    BIGNUM *e = BN_new();
    BN_set_word(e, 65537);

    BIGNUM *p, *q, *n = BN_new(), *phi = BN_new(), *d = BN_new();
    generate_prime(&p);
    generate_prime(&q);
    while (BN_cmp(p, q) == 0) {
        BN_free(q);
        generate_prime(&q);
    }

    BN_mul(n, p, q, ctx); //N
    BIGNUM *p1 = BN_dup(p), *q1 = BN_dup(q);
    BN_sub_word(p1, 1);
    BN_sub_word(q1, 1);
    BN_mul(phi, p1, q1, ctx);

    if (!BN_mod_inverse(d, e, phi, ctx)) {
        std::cerr << "[-] BN_mod_inverse failed\n";
        return 1;
    }

    EVP_PKEY *pkey = build_private_key(n, e, d, p, q);
    unsigned char decrypted[FLAG_SIZE];
    size_t decrypted_len = sizeof(decrypted);

    if (!decrypt_RSA_OAEP(pkey, ciphertext, FLAG_SIZE, decrypted, decrypted_len)) {
        std::cerr << "[-] Decryption failed with OAEP padding\n";
    } else {
        std::cout << "\n[âœ…] Decrypted flag:\n\n";
        std::cout.write(reinterpret_cast<char *>(decrypted), decrypted_len);
        std::cout << "\n";

        std::ofstream fout("decrypted_flag.txt", std::ios::binary);
        fout.write(reinterpret_cast<char *>(decrypted), decrypted_len);
    }

    EVP_PKEY_free(pkey);
    BN_free(p); BN_free(q); BN_free(n); BN_free(e);
    BN_free(phi); BN_free(d); BN_free(p1); BN_free(q1);
    BN_CTX_free(ctx);

    return 0;
}
```

I compile and obtain:

`HACKDAY{T1m3_b4s3D_RNG_1s_4_n0_N0}`