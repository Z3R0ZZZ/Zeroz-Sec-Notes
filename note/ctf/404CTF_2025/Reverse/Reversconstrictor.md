You can download this challenge here: [Reversconstrictor](challenges/chall)

After long research and debugging, I managed to dump a module into a temporary file generated during code execution (`encrypt_key.cpython-39.pyc`)

I analyzed it and recovered functions that will surely be very useful:

```python
def encrypt_key(key):
    for _ in range(100):
        key <<= 1
        key ^= 28822426245224264980979321341345830828356797782055329828562090481380116178932605047916536097759912367507574811007140506795012665313071649493970094581868771201400995139374360577815608383329090103210656811239441222567030843263175788045939510447941542030750571932256144094323129497438168350642218592361235189388565721332503735143045072480576796605508643464856724395849208355789353984327745285879034330837484467961665782705864897713128496005106869640456653659559683849265346017315593794571762231394086134713064707220190583043994656101899455622598958597972721263137718293457676368185324168958757297967087684
        key >>= 1
        key &= 109051226663159329753852712655361641732299866997884252194334358336942491585415479875295813282055589726130083576518139892456534344478282750316593419244506314188673419372046405908627553201165095804542555714314672295089748281211620003277814236498206175511101163526217782040005646393337007890354251307329101818031816904956050245603083420859836404091717206011901780489732016582515541865280619889684277395118340072030441380240101696073919110415984233261149866579378832210321108153068228794726382510988474475602148132965289631295957683363624794221017463029077341994983080187012597951461555452400067297865364263
        key -= 30192244264443276570339417266820821425000308120852003855173657187210512774975257998930431381307567916542287355804911140923844613245045835307895499468937998079600051550088167870781968330783540846793847843565906160661919016260958589152016311435717470936180510788226717267994601294202007594965057260235235670775632982187962998589201876115127904069810375748935472032501147620317590198256980636488859805187975959355302150868894406858968080766062052395340075809777559133433991365763567236747759028423915038949095093046477455353960143902941004723715753803085977215629377804159634990715729987578541999707000127
        key ^= 28822426245224264980979321341345830828356797782055329828562090481380116178932605047916536097759912367507574811007140506795012665313071649493970094581868771201400995139374360577815608383329090103210656811239441222567030843263175788045939510447941542030750571932256144094323129497438168350642218592361235189388565721332503735143045072480576796605508643464856724395849208355789353984327745285879034330837484467961665782705864897713128496005106869640456653659559683849265346017315593794571762231394086134713064707220190583043994656101899455622598958597972721263137718293457676368185324168958757297967087684
        key <<= 1
        key += 4324354
        key >>= 1
    key = abs(key)
    encrypted_bytes = key.to_bytes((key.bit_length() + 7) // 8, byteorder='big')
    return encrypted_bytes

def encode_password(password):
    a = b''
    x_list = [110, -34, -230]
    for i in range(len(password)):
        b = password[i] // 11 + 11
        c = password[i] % 11
        d = b + c
        e = b * c
        r = []
        for i in range(3):
            x = x_list[i]
            y = x ** 2 - d * x + e
            assert y > 0 and y < 65536 and (y not in r)
            r.append(y)
        else:
            for i in range(3):
                a += bytes.fromhex(f'{r[i] // 256:02x}')
                a += bytes.fromhex(f'{r[i] % 256:02x}')
    else:
        return a
```

I also dumped a quite intriguing `base_library.zip`

The way it is presented strongly resembles PyInstaller; fortunately, there is a tool to extract a lot of information from the executable: [https://github.com/extremecoders-re/pyinstxtractor](https://github.com/extremecoders-re/pyinstxtractor)

I will extract the info:

```bash
python3 pyinstxtractor.py /[...]/ctf/404_2025/reverse/Reversconstrictor/chall
[+] Processing /home/neo/Desktop/ctf/404_2025/reverse/Reversconstrictor/chall
[+] Pyinstaller version: 2.1+
[+] Python version: 3.9
[+] Length of package: 16647513 bytes
[+] Found 385 files in CArchive
[+] Beginning extraction...please standby
[+] Possible entry point: pyiboot01_bootstrap.pyc
[+] Possible entry point: pyi_rth__tkinter.pyc
[+] Possible entry point: chall.pyc
[!] Warning: This script is running in a different Python version than the one used to build the executable.
[!] Please run this script in Python 3.9 to prevent extraction errors during unmarshalling
[!] Skipping pyz extraction
[+] Successfully extracted pyinstaller archive: [...]ctf/404_2025/reverse/Reversconstrictor/chall
```

I find a `chall.pyc` file that I will analyze:

```python
import tkinter as tk
import importlib.util
import os
import sys

def import_module():
    module_path = os.path.join(sys._MEIPASS, 'modules/encrypt_key.cpython-39.pyc')
    spec = importlib.util.spec_from_file_location('nom_module', module_path)
    mod = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(mod)
    return mod
module = import_module()

def xor(a, b):
    return bytes((x ^ y for x, y in zip(a, b)))

def validate_password(password):
    if xor(module.encode_password(password.encode('ascii')), module.encrypt_key(95976165392371447739857811656653673143121600389071811768266881989291151289664268756563021450590842202471722647397942271310305361018612287905884505900356120817470)) == b'\xe9J\x1aB\xe2\xc5\xf3S\'\xd6>\n$\x94\x1a\x07\'F\xc6\xa1\x07\xb7\xcc\xec\xe1\x84\xec\xac\xe4\xd64\x8f\xc3\x12\x04\x16$n\x15\xec\xe1\xaee5\xc7\xecOX"\x98EO\x1f2\xb4\x15\xc4\xed\xf4\xcd$\xd3\xd3u\xc2\xf8\xc6\xae\x06\x08\xcd\xff\xe0(\xe9\xb0\xe7\xde6\x90\xcc\xfd\x02}%\x1a\x1a\xc9#\x10\xc2\x86\x06\x08\xcd\xfe&\xb8K\x0f)\x9a\xb6\xb9\x02\x17\xa0\xd8\xe4]\x98\xf5*\x154<\x06\x875\xbd\x05@\xe6\x88\xe3&6%\xcc\x18\x06\\%\xa4\x1a7!\xfe\xc3\xae\x06\x08\xcd\xff\xe2\x18\xe2x\xe0\x927x\r\xfa\xa6\xbd\xe67\x97\xf7\xe5)f\x94\xc8\xbdv\r\xef\x12\x1bZ\xe8e\xf3S\'\xd6>\n"8\x1be\x9c\xdf\xe8\x9b\x06\xb7\x0b3V\x1f\xedN\x87\xbbI!C>8z%\xc0\xeaM\xb5\xd1p\xd1\x0f|A\xd7B\x03\xc54\xd5T\xb9\xfd\x88;\xbf\x10\x81L\x90L\x0b\xff\xed\xe1\xe5dQ\xc4\x17\xd5\xafUl\xec':
        label.config(text='Correct password!')
    else:
        label.config(text='Incorrect password!')
root = tk.Tk()
root.title('RÃªve en Python')
root.geometry('300x200')
label = tk.Label(root, text='Enter the password:')
label.pack(pady=10)
entry_password = tk.Entry(root, width=20)
entry_password.pack(pady=5)
validate_button = tk.Button(root, text='Validate', command=lambda: validate_password(entry_password.get()))
validate_button.pack(pady=5)
root.mainloop()
```

Perfect, I have everything I need thanks to the `validate_password` function and the module to perform the reverse!

```python
# === Original functions recovered ===

def encrypt_key(key):
    for _ in range(100):
        key <<= 1
        key ^= 28822426245224264980979321341345830828356797782055329828562090481380116178932605047916536097759912367507574811007140506795012665313071649493970094581868771201400995139374360577815608383329090103210656811239441222567030843263175788045939510447941542030750571932256144094323129497438168350642218592361235189388565721332503735143045072480576796605508643464856724395849208355789353984327745285879034330837484467961665782705864897713128496005106869640456653659559683849265346017315593794571762231394086134713064707220190583043994656101899455622598958597972721263137718293457676368185324168958757297967087684
        key >>= 1
        key &= 109051226663159329753852712655361641732299866997884252194334358336942491585415479875295813282055589726130083576518139892456534344478282750316593419244506314188673419372046405908627553201165095804542555714314672295089748281211620003277814236498206175511101163526217782040005646393337007890354251307329101818031816904956050245603083420859836404091717206011901780489732016582515541865280619889684277395118340072030441380240101696073919110415984233261149866579378832210321108153068228794726382510988474475602148132965289631295957683363624794221017463029077341994983080187012597951461555452400067297865364263
        key -= 30192244264443276570339417266820821425000308120852003855173657187210512774975257998930431381307567916542287355804911140923844613245045835307895499468937998079600051550088167870781968330783540846793847843565906160661919016260958589152016311435717470936180510788226717267994601294202007594965057260235235670775632982187962998589201876115127904069810375748935472032501147620317590198256980636488859805187975959355302150868894406858968080766062052395340075809777559133433991365763567236747759028423915038949095093046477455353960143902941004723715753803085977215629377804159634990715729987578541999707000127
        key ^= 28822426245224264980979321341345830828356797782055329828562090481380116178932605047916536097759912367507574811007140506795012665313071649493970094581868771201400995139374360577815608383329090103210656811239441222567030843263175788045939510447941542030750571932256144094323129497438168350642218592361235189388565721332503735143045072480576796605508643464856724395849208355789353984327745285879034330837484467961665782705864897713128496005106869640456653659559683849265346017315593794571762231394086134713064707220190583043994656101899455622598958597972721263137718293457676368185324168958757297967087684
        key <<= 1
        key += 4324354
        key >>= 1
    key = abs(key)
    encrypted_bytes = key.to_bytes((key.bit_length() + 7) // 8, byteorder='big')
    return encrypted_bytes

def encode_password(password):
    a = b''
    x_list = [110, -34, -230]
    for i in range(len(password)):
        b = password[i] // 11 + 11
        c = password[i] % 11
        d = b + c
        e = b * c
        r = []
        for i in range(3):
            x = x_list[i]
            y = x ** 2 - d * x + e
            assert y > 0 and y < 65536 and (y not in r)
            r.append(y)
        else:
            for i in range(3):
                a += bytes.fromhex(f'{r[i] // 256:02x}')
                a += bytes.fromhex(f'{r[i] % 256:02x}')
    else:
        return a

def xor(a, b):
    return bytes(x ^ y for x, y in zip(a, b))

# === Provided data ===

target_bytes = b'\xe9J\x1aB...Ul\xec'  # Truncated here

# === Resolution steps ===

hardcoded_int = 95976165392371447739857811656653673143121600389071811768266881989291151289664268756563021450590842202471722647397942271310305361018612287905884505900356120817470

# 1. Recompute encrypted key
encrypted = encrypt_key(hardcoded_int)

# 2. XOR to get encode_password of the password
encoded_password = xor(target_bytes, encrypted)

# 3. Decode each character from its 6 bytes
def decode_password(encoded):
    x_list = [110, -34, -230]
    password = []
    for i in range(0, len(encoded), 6):
        block = encoded[i:i+6]
        y_values = [block[j] << 8 | block[j+1] for j in range(0, 6, 2)]
        for b in range(11, 35):
            for c in range(0, 11):
                d = b + c
                e = b * c
                r = []
                valid = True
                for x in x_list:
                    y = x**2 - d*x + e
                    if y <= 0 or y >= 65536 or y in r:
                        valid = False
                        break
                    r.append(y)
                if valid and sorted(r) == sorted(y_values):
                    password.append((b - 11) * 11 + c)
                    break
    return bytes(password)
recovered_password = decode_password(encoded_password)
print("â Password found:", recovered_password.decode())
```

404CTF{D0\_y0U\_L0v3\_Pyth02?1\_l0v3\_pYt60n!}